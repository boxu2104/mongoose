{% extends "markdown.html" %}
{% block markdown %}
# Development and Runtime Environment

## Pip, Virtualenv, and VirtualenvWrapper

We used [pip](http://www.pip-installer.org/en/latest/) to manage the dependencies for our language. One useful strategy was to keep an up-to-date `requirements.txt` file that contained all the dependencies. To install the latest dependencies, a simple `pip install -r requirements.txt` was needed.

[Virtualenv](http://www.virtualenv.org/en/latest/) provides distinct python "virtual environments" that allow a clean separation between the OS-default python installation/binaries, and the project-specific python installation/binaries. Virtualenv and pip work together to provide a clean development environment that we could then commit to our hosted Git repository ([Github](https://github.com/)) for distribution among team members.

[Virtualenvwrapper](virtualenvwrapper.readthedocs.org) is a convenient collection of command-line programs and standards (e.g. one canonical .virtualenv folder) that make using Virtualenv more painless.

## Management Script (manage.sh)
When developing our project we separated our code into a logical hierarchy with there being a separate directory for the frontend, backend and tests. This was nice for code structure, but led to a dependency hell. At first we were using relative imports in the directories, but that led to the code working when running it from one directory, but not working when running from another directory. To fix all these issues we created a management script called `manage.sh`. This script added the proper directories to the python path, leading to a runtime environment that worked everytime without issues. We were then able to run the python shell, the tests, and the main mongoose program without worrying.

## Git and Github
The distributed version control system Git (and Github, our hosted repository) were instrumental in this project. Git allows developers to work independently on one or more branches within a given repository, and makes merging commits and branches as painless as possible.

We strived to make our commits as granular as possible, and to write meaningful commit messages. This style of committing code facilitates *communication* about the code among the developers, and clearly communicates the *intention* of code updates.

## Automated testing
As mentioned in the [Test Plan](test-plan.html), the Nose tests framework was used to facilitate test discovery and run tests. Running tests in verbose mode with nose is as easy as:

    $ ./manage.sh tests -v

For those that desired, sniffer was available to rerun the test suite upon each change in the source code directory on the filesystem. Running sniffer is also easy:

    $ sniffer

{% endblock %}
