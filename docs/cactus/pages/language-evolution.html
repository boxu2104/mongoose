{% extends "markdown.html" %}
{% block markdown %}
# Language Evolution

Originally, our language consisted of actors and a call to a simulate function which would take in actor references and run the body of each actor block every time-step. We realized that we wanted global state and a means to access the agents' references. We created a global environment to contain the agents that is also able to perform its own actions. The environment is also a convenient way to organize the agents and their relationships. 

Instead of having to explicitly end the simulation with additional logic, we decided to allow the simulation to run freely and included invariants that would be checked periodically. Depending on which event occurred and which invariant was broken, the simulation could execute varying blocks of code. For example, in a tic-tac-toe simulation, we would want to recognize which player won the game and act accordingly. All the programmer must do is specify the invariants, the frequency with which they are checked and what action they wish for the simulation to take upon these events. Mongoose provides succinct syntax for doing so. 

We then realized that the programmer may wish to have some final analysis computed regardless of which event caused the simulation to halt. This motivated the analysis block. We decided to make our language more objected-oriented by giving our agents and the environment their own constructors, and making their actions into methods. Originally, we used spawn and kill methods to construct and destruct agents and a simulate function to populate the simulation. We moved these actions into the objects themselves. 

We wished to provide some form of statistical capabilities to the programmer. At first we were going to provide aggregators in the form of function decorators, which would enable the programmer to compute averages and other common analysis tools. We later decided it would be more valuable to provide the programmer with easy use of randomization. We added a weighted value statement which selects a value using weighted probabilities, as well as a probabilistic selection statement which runs blocks of code probabilistically. 

At the outset of our design phase, we wanted to include multi-threading and a state saving mechanism. These proved to be too rich for us to implement for Mongoose 1.0. Some other syntax we originally planned to include consisted of the requirement to use explicit scoping, dynamic lists and advanced iteration constructs. 

In order to create our lexer and parser, we used PLY, the Python Lex & Yacc. This allowed us to specify the lexer regular expressions, grammar rules, semantic actions, and error productions.

We used Nose to organize unit tests for our compiler. Sniffer was used for some tests to run on every file save. For environment management, we used virtualenvwrapper. For markdown-to-HTML doc conversion (and pushing docs to Amazon S3 for hosting), we used cactus.py. We used GitHub as our distributed version control system. To edit documents we used Sublime Text, Vim and Emacs. 

We used the GitHub issues functionality and Google Drive comments to publicize a potential gap between the LRM and the compiler. Once these were publicized, the relevant teammates discussed how to maintain consistency or make necessary changes. The project manager then confirmed this decision and updated the relevant code and documents.  

{% endblock %}
