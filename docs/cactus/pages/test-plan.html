{% extends "markdown.html" %}
{% block markdown %}
# Test Plan

## Testing tools
We used the [nose test framework](https://nose.readthedocs.org/en/latest/), which provides nice test auto-discovery, to make testing as painless as possible. Another useful tool was [sniffer](https://github.com/jeffh/sniffer), which automatically re-runs the entire test each time a file is changed in the source code directory.

## Unit testing
Unit testing was useful for "driving out" the development of new features. These are low-level, granular tests used to ensure that a feature (e.g. list access) works correctly. Individual approaches to testing differ, but one effective approach is to write a failing unit test (that reflects the desired functionality) and then implement the feature until the test passes (this is done incrementally, building upon the small improvements tested in the last unit test).

A future improvement would be to increase our unit test "coverage", i.e. the amount of our source code being tested.

## Integration testing
Integration testing is the *end-to-end* testing that runs a complete source code program through the entire compiler stack. As we finished the implementation of more language features, we added complete Mongoose source files, reflecting the new features, to a "working" sample code directory. We also added integration tests to ensure that those files continued to work correctly when we made changes to the codebase.

The combination of unit testing and integration testing gives us the confidence to say that if a Mongoose program is in our working directory, it actually works as intended.

8: Testing

Our testing methodology for Mongoose involved using a combination of unit test for covering the functional components of the our language: lexer, parser, semantic analyser, and backend/code generator along with integration tests to verify our specifications from end-to-end yielding in the output results. 

In order to automate our testing, we used Python's Nose framework, which is an extension of Python's unittest library. The benefits included test discovery, which allowed us to test our entire project in one batch. Nose also allowed us to readily call assertions in our testing files, which served the double role of verifying and documenting our implementations.

Nose's features were added into our shellscript manage.sh, used for directory management and testing functionality. Error lines are output to the shell.

Ex: Shell script: ./manage.sh <files to test> <set of tests to run> 



Files 			Testing Goal
test_backend.py:		Unit tests of backend functionality, covering different AST nodes

test_builtins.py:	Tested print functionality

test_functions.py	Tested Mongoose supported functions, covering cases of addition, functions, variables and constants

test_integration.py 	Tested sample .mon (mongoose) source code for the full compiler

test_lexer.py		Tests the functionality of the lexer based on various expected lines of code such as function definitions, variable initializations, 

test_lists.py		Tested static list functionality

test_parser.py		Tested parser AST, tested sample code blocks and coverage of various code blocks

test_scope.py		Tested scoping rules


[Tests Examples](/example-tests.html/)
{% endblock %}
